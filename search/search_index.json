{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PowerTunnel Powerful and extensible cross-platform proxy server PowerTunnel is an extensible proxy server with user interface and powerful API. The server is built on top of LittleProxy and its functionality can be extended with plugins developed using PowerTunnel SDK. PowerTunnel plugins are developed in Java, or any other JVM language such as Kotlin. PowerTunnel SDK allows you to write plugins which are able to filter and modify HTTP(S) traffic and DNS requests. Any plugin you write is supported by Desktop and Android editions without writing any additional platform-dependent code. The codebase for PowerTunnel client versions consists of two parts: the platform code and PowerTunnel Core, which manages the proxy server and implements the SDK.","title":"Introduction"},{"location":"getting-started/","text":"Getting Started The language for developing PowerTunnel plugins is Java or any JVM-compatible programming language. You also need Java Development Kit (JDK) for plugin development. Warning If you intend to use your plugin on Android versions older than Android 8 Oreo, you should avoid using Java 8 APIs and functional interfaces as they are not supported on older Android versions. Getting SDK PowerTunnel SDK is a Java library that contains all the required definitions for plugin development. The implementations of these definitions are found in PowerTunnel Core \u2013 the base component of the Desktop and Android editions, with an SDK version corresponding to each Core version. While the SDK is committed to supporting upwards compatibility, it is constantly evolving, so the minimum required target SDK version is the maximum required SDK version for API calls by your plugin. Tip Open the About page to determine the version of the Core shipped with your application. Installing SDK To use PowerTunnel SDK, you need add the SDK jarfile as a dependency to your project. Note You should never include the SDK files in your plugin artifact","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The language for developing PowerTunnel plugins is Java or any JVM-compatible programming language. You also need Java Development Kit (JDK) for plugin development. Warning If you intend to use your plugin on Android versions older than Android 8 Oreo, you should avoid using Java 8 APIs and functional interfaces as they are not supported on older Android versions.","title":"Getting Started"},{"location":"getting-started/#getting-sdk","text":"PowerTunnel SDK is a Java library that contains all the required definitions for plugin development. The implementations of these definitions are found in PowerTunnel Core \u2013 the base component of the Desktop and Android editions, with an SDK version corresponding to each Core version. While the SDK is committed to supporting upwards compatibility, it is constantly evolving, so the minimum required target SDK version is the maximum required SDK version for API calls by your plugin. Tip Open the About page to determine the version of the Core shipped with your application.","title":"Getting SDK"},{"location":"getting-started/#installing-sdk","text":"To use PowerTunnel SDK, you need add the SDK jarfile as a dependency to your project. Note You should never include the SDK files in your plugin artifact","title":"Installing SDK"},{"location":"js-hooks/","text":"JavaScript Hooks It is possible to extend PowerTunnel functionality using hooks written in JavaScript. To add hooks support, you need to install PowerTunnel-Hooks plugin. Hooks are slower and have less functionality than plugins, so if you need to develop a stable and powerful solution rather than a quick and dirty extension to test specific functionality at the moment, please consider developing a plugin using the SDK. ...","title":"JavaScript Hooks"},{"location":"js-hooks/#javascript-hooks","text":"It is possible to extend PowerTunnel functionality using hooks written in JavaScript. To add hooks support, you need to install PowerTunnel-Hooks plugin. Hooks are slower and have less functionality than plugins, so if you need to develop a stable and powerful solution rather than a quick and dirty extension to test specific functionality at the moment, please consider developing a plugin using the SDK. ...","title":"JavaScript Hooks"},{"location":"plugins/","text":"Developing","title":"Developing"},{"location":"plugins/#developing","text":"","title":"Developing"},{"location":"plugins/hello-world/","text":"Developing Hello World Plugin In this guide you will learn how to develop a simple plugin that logs \"Hello World\" on bootstrap, and blocks requests to specific websites. The resulting project can be found here . It assumes you are already familiar with Java. Preparing Main Class First, create an arbitrary package and a class in it, for example, com.example.plugin.MyPlugin . Every plugin should extend PowerTunnelPlugin class to get access to plugin lifecycle: package com.example.plugin ; import io.github.krlvm.powertunnel.sdk.plugin.PowerTunnelPlugin ; public class MyPlugin extends PowerTunnelPlugin { ... } Listening to server lifecycle The key plugin method is onProxyInitialization - it is being called after injecting the last plugin and before starting the proxy server. During the initialization, you can modify proxy server configuration and bind your server lifecycle listeners - you can listen to server status change (starting, running, stopping, not running) and proxy server lifecycle events - control the traffic when it's going from client to proxy, from proxy to server, from server to proxy, and from proxy to client, and control DNS requests. To bind a server lifecycle listener, use method registerServerListener , which accepts ServerListener instance as argument. Tip It's more convenient to extend ServerAdapter than ServerListener @Override public void onProxyInitialization ( ProxyServer proxy ) { System . out . println ( \"Hello World!\" ); registerServerListener ( new ServerAdapter () { @Override public void onProxyStatusChanged ( ProxyStatus status ) { System . out . println ( \"status = \" + status . name ()); } }); } Listening to proxy lifecycle Blocking requests To listen to proxy lifecycle events, you need to register your listener in onProxyInitialization using method registerProxyListener , which accepts ProxyListener instance and (optionally) priority for the given listener instance. Tip It's more convenient to extend ProxyAdapter than ProxyListener In this article, we are developing a plugin that restricts access to some websites, the best time for filtering is the transfer of a packet from the client to the proxy - corresponding ProxyListener lifecycle callback is onClientToProxyRequest . For example, we can restrict access to google.com using following code: @Override public void onProxyInitialization ( ProxyServer proxy ) { registerProxyListener ( new ProxyAdapter () { @Override public void onClientToProxyRequest ( ProxyRequest request ) { if ( request . getHost (). endsWith ( \"github.com\" )) { request . setBlocked ( true ); } } }); } Calling method setBlocked is equivalent to calling method setResponse with body text \"Access denied by proxy server\" and status code 403. Request is considered blocked if response is not null, if response is null, the request goes further along the chain. You can check if a request is blocked by calling the isBlocked method. Important It's highly recommended to check if the request is blocked before inspecting it, because it might be blocked by another plugin and there's no need to modify it as it will not reach its destination. If you want to set custom response, use setResponse method: @Override public void onProxyInitialization ( ProxyServer proxy ) { registerProxyListener ( new ProxyAdapter () { @Override public void onClientToProxyRequest ( @NotNull ProxyRequest request ) { if ( request . isBlocked ()) { // Request is already blocked by another plugin return ; } if ( request . getHost (). endsWith ( \"github.com\" )) { request . setResponse ( proxy . getResponseBuilder ( \"This website is blocked\" , 403 ) . contentType ( \"text/plain\" ) . build () ); } } }); } Faq Why can't I see the blocking message? You may notice that website you blocked just doesn't load without showing any message. This is because most likely (in 99% of cases) you are loading the site over HTTPS , where S stands for Secure: you cannot just interfere with HTTPS traffic without a MITM attack. Information on using MITM is found below. If you're looking for plain HTTP website for testing, check neverssl.com Modifying responses To modify the response, it's recommended to use onProxyToClientResponse lifecycle method. Since most websites use HTTPS, you need to use a MITM attack to decrypt packets. You should also make sure that you're working with the full packet and not with a chunk. PowerTunnel provides a very simple way to do this. Caution You will need to install a Root CA on every machine, the traffic that you are MITMing. Some webservers validates the certificate, so they could break in unexpected ways. @Override public void onProxyInitialization ( ProxyServer proxy ) { proxy . setMITMEnabled ( true ); proxy . setFullResponse ( true ); } For example, you want to add \"Hello World\" to the beginning of the web page. You will need to check that you aren't working with a chunk. Warning Make sure that MITM is enabling before modifying request to make sure you will not break encrypted HTTPS packet @Override public void onProxyToClientResponse ( @NotNull ProxyResponse response ) { if ( ! proxy . isMITMEnabled ()) return ; if ( ! response . isDataPacket ()) return ; response . setRaw ( \"<b>Hello World!</b>\" + response . raw ()); } Creating manifest To make your plugin work, you need to provide a manifest, as described in previous article. Assuming our main class is named MyPlugin and it's located in package com.example.plugin , we should create a plugin.ini in project resources with the following content: id : my-plugin version : 1.0 versionCode : 1 name : My Plugin description : Hello World Plugin author : Unknown Author homepage : https://github.com/krlvm/PowerTunnel-Plugin-Template mainClass : com.example.plugin.MyPlugin targetSdkVersion : 99 Testing plugin Since Desktop and Android editions are sharing the same codebase, it's easier to test the plugin on Desktop version, while it is guaranteed that it will work in the same way on Android. Note Android uses its own Java Virtual Machine \u2014 Android Runtime (ART), previously known as Dalvik. To produce Android-compatible jarfile, the plugin code should be compiled to .dex file. PowerTunnel uses D8 tool from Android SDK to produce Android-compatible jars, it will be available later. To test plugin, you need to produce a .jar artifact and put the jarfile into plugins directory of PowerTunnel distribution directory. If the proxy server was running at the moment you pasted the file into plugins directory, you need to completely restart PowerTunnel. To be continued The documentation is not yet complete, if you have any suggestions or questions, please open a new issue on GitHub.","title":"Hello World Plugin"},{"location":"plugins/hello-world/#developing-hello-world-plugin","text":"In this guide you will learn how to develop a simple plugin that logs \"Hello World\" on bootstrap, and blocks requests to specific websites. The resulting project can be found here . It assumes you are already familiar with Java.","title":"Developing Hello World Plugin"},{"location":"plugins/hello-world/#preparing-main-class","text":"First, create an arbitrary package and a class in it, for example, com.example.plugin.MyPlugin . Every plugin should extend PowerTunnelPlugin class to get access to plugin lifecycle: package com.example.plugin ; import io.github.krlvm.powertunnel.sdk.plugin.PowerTunnelPlugin ; public class MyPlugin extends PowerTunnelPlugin { ... }","title":"Preparing Main Class"},{"location":"plugins/hello-world/#listening-to-server-lifecycle","text":"The key plugin method is onProxyInitialization - it is being called after injecting the last plugin and before starting the proxy server. During the initialization, you can modify proxy server configuration and bind your server lifecycle listeners - you can listen to server status change (starting, running, stopping, not running) and proxy server lifecycle events - control the traffic when it's going from client to proxy, from proxy to server, from server to proxy, and from proxy to client, and control DNS requests. To bind a server lifecycle listener, use method registerServerListener , which accepts ServerListener instance as argument. Tip It's more convenient to extend ServerAdapter than ServerListener @Override public void onProxyInitialization ( ProxyServer proxy ) { System . out . println ( \"Hello World!\" ); registerServerListener ( new ServerAdapter () { @Override public void onProxyStatusChanged ( ProxyStatus status ) { System . out . println ( \"status = \" + status . name ()); } }); }","title":"Listening to server lifecycle"},{"location":"plugins/hello-world/#listening-to-proxy-lifecycle","text":"","title":"Listening to proxy lifecycle"},{"location":"plugins/hello-world/#blocking-requests","text":"To listen to proxy lifecycle events, you need to register your listener in onProxyInitialization using method registerProxyListener , which accepts ProxyListener instance and (optionally) priority for the given listener instance. Tip It's more convenient to extend ProxyAdapter than ProxyListener In this article, we are developing a plugin that restricts access to some websites, the best time for filtering is the transfer of a packet from the client to the proxy - corresponding ProxyListener lifecycle callback is onClientToProxyRequest . For example, we can restrict access to google.com using following code: @Override public void onProxyInitialization ( ProxyServer proxy ) { registerProxyListener ( new ProxyAdapter () { @Override public void onClientToProxyRequest ( ProxyRequest request ) { if ( request . getHost (). endsWith ( \"github.com\" )) { request . setBlocked ( true ); } } }); } Calling method setBlocked is equivalent to calling method setResponse with body text \"Access denied by proxy server\" and status code 403. Request is considered blocked if response is not null, if response is null, the request goes further along the chain. You can check if a request is blocked by calling the isBlocked method. Important It's highly recommended to check if the request is blocked before inspecting it, because it might be blocked by another plugin and there's no need to modify it as it will not reach its destination. If you want to set custom response, use setResponse method: @Override public void onProxyInitialization ( ProxyServer proxy ) { registerProxyListener ( new ProxyAdapter () { @Override public void onClientToProxyRequest ( @NotNull ProxyRequest request ) { if ( request . isBlocked ()) { // Request is already blocked by another plugin return ; } if ( request . getHost (). endsWith ( \"github.com\" )) { request . setResponse ( proxy . getResponseBuilder ( \"This website is blocked\" , 403 ) . contentType ( \"text/plain\" ) . build () ); } } }); } Faq Why can't I see the blocking message? You may notice that website you blocked just doesn't load without showing any message. This is because most likely (in 99% of cases) you are loading the site over HTTPS , where S stands for Secure: you cannot just interfere with HTTPS traffic without a MITM attack. Information on using MITM is found below. If you're looking for plain HTTP website for testing, check neverssl.com","title":"Blocking requests"},{"location":"plugins/hello-world/#modifying-responses","text":"To modify the response, it's recommended to use onProxyToClientResponse lifecycle method. Since most websites use HTTPS, you need to use a MITM attack to decrypt packets. You should also make sure that you're working with the full packet and not with a chunk. PowerTunnel provides a very simple way to do this. Caution You will need to install a Root CA on every machine, the traffic that you are MITMing. Some webservers validates the certificate, so they could break in unexpected ways. @Override public void onProxyInitialization ( ProxyServer proxy ) { proxy . setMITMEnabled ( true ); proxy . setFullResponse ( true ); } For example, you want to add \"Hello World\" to the beginning of the web page. You will need to check that you aren't working with a chunk. Warning Make sure that MITM is enabling before modifying request to make sure you will not break encrypted HTTPS packet @Override public void onProxyToClientResponse ( @NotNull ProxyResponse response ) { if ( ! proxy . isMITMEnabled ()) return ; if ( ! response . isDataPacket ()) return ; response . setRaw ( \"<b>Hello World!</b>\" + response . raw ()); }","title":"Modifying responses"},{"location":"plugins/hello-world/#creating-manifest","text":"To make your plugin work, you need to provide a manifest, as described in previous article. Assuming our main class is named MyPlugin and it's located in package com.example.plugin , we should create a plugin.ini in project resources with the following content: id : my-plugin version : 1.0 versionCode : 1 name : My Plugin description : Hello World Plugin author : Unknown Author homepage : https://github.com/krlvm/PowerTunnel-Plugin-Template mainClass : com.example.plugin.MyPlugin targetSdkVersion : 99","title":"Creating manifest"},{"location":"plugins/hello-world/#testing-plugin","text":"Since Desktop and Android editions are sharing the same codebase, it's easier to test the plugin on Desktop version, while it is guaranteed that it will work in the same way on Android. Note Android uses its own Java Virtual Machine \u2014 Android Runtime (ART), previously known as Dalvik. To produce Android-compatible jarfile, the plugin code should be compiled to .dex file. PowerTunnel uses D8 tool from Android SDK to produce Android-compatible jars, it will be available later. To test plugin, you need to produce a .jar artifact and put the jarfile into plugins directory of PowerTunnel distribution directory. If the proxy server was running at the moment you pasted the file into plugins directory, you need to completely restart PowerTunnel.","title":"Testing plugin"},{"location":"plugins/hello-world/#to-be-continued","text":"The documentation is not yet complete, if you have any suggestions or questions, please open a new issue on GitHub.","title":"To be continued"},{"location":"plugins/system/","text":"Plugin System PowerTunnel provides a simple plugin system: during the proxy server bootstrap it injects every jarfile found in the plugins directory into the JVM and initializes plugin's main class written in the plugin manifest. Each PowerTunnel plugin is a regular .jar file which contains a manifest, and, optionally, preferences schema and locale files. Plugin Manifest Plugin manifest is a file named plugin.ini , which contains basic information about the plugin: unique identifier, name, version and entry point (main class). Required fields id - unique identifier of the plugin Filename of the default plugin configuration file is the same as plugin ID. version - plugin version display name versionCode - plugin version code name - plugin display name mainClass - plugin entry point targetSdkVersion - minimum required SDK to work Optional fields description - plugin description author - plugin author homepage - plugin homepage (e.g. GitHub repository if it's open-source)","title":"Plugin System"},{"location":"plugins/system/#plugin-system","text":"PowerTunnel provides a simple plugin system: during the proxy server bootstrap it injects every jarfile found in the plugins directory into the JVM and initializes plugin's main class written in the plugin manifest. Each PowerTunnel plugin is a regular .jar file which contains a manifest, and, optionally, preferences schema and locale files.","title":"Plugin System"},{"location":"plugins/system/#plugin-manifest","text":"Plugin manifest is a file named plugin.ini , which contains basic information about the plugin: unique identifier, name, version and entry point (main class).","title":"Plugin Manifest"},{"location":"plugins/system/#required-fields","text":"id - unique identifier of the plugin Filename of the default plugin configuration file is the same as plugin ID. version - plugin version display name versionCode - plugin version code name - plugin display name mainClass - plugin entry point targetSdkVersion - minimum required SDK to work","title":"Required fields"},{"location":"plugins/system/#optional-fields","text":"description - plugin description author - plugin author homepage - plugin homepage (e.g. GitHub repository if it's open-source)","title":"Optional fields"}]}